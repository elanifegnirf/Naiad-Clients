// -----------------------------------------------------------------------------
//
// NsOpObject.h
//
// Naiad Studio class for representing an Op, header file.
//
// Copyright (c) 2011 Exotic Matter AB. All rights reserved.
//
// This file is part of Open Naiad Studio.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// * Neither the name of Exotic Matter AB nor its contributors may be used to
// endorse or promote products derived from this software without specific
// prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
// ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
// -----------------------------------------------------------------------------

#ifndef NS_OP_OBJECT_H
#define NS_OP_OBJECT_H

#include "NsValueObject.h"
#include "NsBodyCache.h"
#include "NsStringUtils.h"
#include <NiTypes.h>
#include <NgOp.h>   // Full include required for covariant return types.
#include <NgNelContext.h>
#include <QMap>
#include <QList>
#include <QString>
#include <QStringList>

class NsValueObjectHandle;
class NsPlugObject;
class NsInputPlugObject;
class NsOutputPlugObject;
class NsBodyInputPlugObject;
class NsFieldInputPlugObject;
class NsBodyOutputPlugObject;
class NsFieldOutputPlugObject;

// -----------------------------------------------------------------------------

// NsOpObject
// ----------
//! Instances of this class store information about Op's. Also, instances
//! are connected to signals generated by commands that change Op settings
//! on the server.

class NsOpObject : public NsValueObject
{
    Q_OBJECT

public:

    enum Condition 
    {   
        None = 0, 
        Stepping, 
        Error, 
        Warning 
    };

public:     // NsValueObject interface.

    virtual
    ~NsOpObject();

    virtual const Ng::Op&
    constNbValueObject() const;

    virtual Ng::Op&
    mutableNbValueObject();

    // virtual void
    // bindNelContext(const NtTimeBundle &tb) const;

    // virtual void
    // unbindNelContext() const;

    virtual bool
    isEnabled() const;

    virtual QList<const NsBodyObject*>
    constCachedBodies() const
    { return _empBodyCache.constBodies(); }

    virtual QList<NsBodyObject*>
    mutableCachedBodies()
    { return _empBodyCache.mutableBodies(); }

public:

    explicit
    NsOpObject(Ng::Op  &op,
               QObject *parent = 0);

    const Ng::Op&
    constNgOp() const
    { return *_op; }

    Ng::Op&
    mutableNgOp()
    { return *_op; }

    const NsBodyCache&
    constEmpBodyCache()  const
    { return _empBodyCache;  }

    NsBodyCache&
    mutableEmpBodyCache()
    { return _empBodyCache;  }

    QString
    state() const;

    bool
    hasParam(const QString &paramName) const;            

    const QString&
    typeName() const
    { return _typeName; }

    const QString&
    familyName() const
    { return _familyName; }

    QStringList
    categoryNames() const;

    Condition
    condition() const;

    void
    setCondition(Condition cond);

    void
    updateEmpBodyCache();

    void
    updateBodyCachePolicy();

public:     // Inputs/outputs.

    //! Total number of plugs.
    int
    plugCount() const
    { return _orderedPlugs.size(); }

    //! Total number of inputs (body + field).
    int
    inputCount() const
    { return _orderedInputs.size(); }

    //! Total number of outputs (body + field).
    int
    outputCount() const
    { return _orderedOutputs.size(); }

    //! Number of body inputs.
    int
    bodyInputCount() const
    { return _orderedBodyInputs.size(); }

    //! Number of field inputs.
    int
    fieldInputCount() const
    { return _orderedFieldInputs.size(); }

    //! Number of body outputs.
    int
    bodyOutputCount() const
    { return _orderedBodyOutputs.size(); }

    //! Number of field outputs.
    int
    fieldOutputCount() const
    { return _orderedFieldOutputs.size(); }


    const QList<NsPlugObject*>&
    mutablePlugs()
    { return _orderedPlugs; }

    //! Returns a list of non-const pointers to all inputs.
    const QList<NsInputPlugObject*>&
    mutableInputs()
    { return _orderedInputs; }

    //! Returns a list of non-const pointers to all outputs.
    const QList<NsOutputPlugObject*>&
    mutableOutputs()
    { return _orderedOutputs; }

    const QList<NsBodyInputPlugObject*>&
    mutableBodyInputs()
    { return _orderedBodyInputs; }

    const QList<NsFieldInputPlugObject*>&
    mutableFieldInputs()
    { return _orderedFieldInputs; }

    const QList<NsBodyOutputPlugObject*>&
    mutableBodyOutputs()
    { return _orderedBodyOutputs; }

    const QList<NsFieldOutputPlugObject*>&
    mutableFieldOutputs()
    { return _orderedFieldOutputs; }


    QList<const NsPlugObject*>
    constPlugs() const
    { return constPtrList(_orderedPlugs); }

    QList<const NsInputPlugObject*>
    constInputs() const
    { return constPtrList(_orderedInputs); }

    QList<const NsOutputPlugObject*>
    constOutputs() const
    { return constPtrList(_orderedOutputs); }

    QList<const NsBodyInputPlugObject*>
    constBodyInputs() const
    { return constPtrList(_orderedBodyInputs); }

    QList<const NsFieldInputPlugObject*>
    constFieldInputs() const
    { return constPtrList(_orderedFieldInputs); }

    QList<const NsBodyOutputPlugObject*>
    constBodyOutputs() const
    { return constPtrList(_orderedBodyOutputs); }

    QList<const NsFieldOutputPlugObject*>
    constFieldOutputs() const
    { return constPtrList(_orderedFieldOutputs); }


    QStringList
    plugNames() const
    { return _plugs.keys(); }

    QStringList
    inputNames() const
    { return _inputs.keys(); }

    QStringList
    outputNames() const
    { return _outputs.keys(); }

    QStringList
    bodyInputNames() const
    { return _bodyInputs.keys(); }

    QStringList
    fieldInputNames() const
    { return _fieldInputs.keys(); }

    QStringList
    bodyOutputNames() const
    { return _bodyOutputs.keys(); }

    QStringList
    fieldOutputNames() const
    { return _fieldOutputs.keys(); }


    const NsPlugObject*
    queryConstPlug(const QString &name) const;

    const NsInputPlugObject*
    queryConstInput(const QString &name) const;

    const NsOutputPlugObject*
    queryConstOutput(const QString &name) const;

    const NsBodyInputPlugObject*
    queryConstBodyInput(const QString &name) const;

    const NsFieldInputPlugObject*
    queryConstFieldInput(const QString &name) const;

    const NsBodyOutputPlugObject*
    queryConstBodyOutput(const QString &name) const;

    const NsFieldOutputPlugObject*
    queryConstFieldOutput(const QString &name) const;


    NsPlugObject*
    queryMutablePlug(const QString &name);

    NsInputPlugObject*
    queryMutableInput(const QString &name);

    NsOutputPlugObject*
    queryMutableOutput(const QString &name);

    NsBodyInputPlugObject*
    queryMutableBodyInput(const QString &name);

    NsFieldInputPlugObject*
    queryMutableFieldInput(const QString &name);

    NsBodyOutputPlugObject*
    queryMutableBodyOutput(const QString &name);

    NsFieldOutputPlugObject*
    queryMutableFieldOutput(const QString &name);

public:

    void
    emitStepBegin(const NtTimeBundle &tb);

    void
    emitStepEnd(const NtTimeBundle &tb);

    void
    emitNameChanged(const QString &oldName, const QString &newName)
    { emit nameChanged(oldName, newName); }

    void
    emitStateChanged(/*const QString &opState*/)
    { emit stateChanged(/*opState*/); }

protected slots:

    //void
    //onFeedChanged(const QString &inputLongName,
    //              const QString &plugLongName,
    //              bool           success);

    void
    onValueChanged(const QString &valueLongName,
                   const QString &expr,
                   int            comp,
                   bool           success);

    void
    onProjectPathChanged(const QString &path,
                         bool           success);

    void
    onCurrentVisibleFrameChanged(int  cvf,
                                 bool update3DView,               
                                 bool success);

signals:

    //! Emitted when condition is changed.
    void
    conditionChanged(NsOpObject::Condition cond);

    //! Emitted when name is changed.
    void
    nameChanged(const QString &oldOpInstance,
                const QString &newOpInstance);

    //! Emitted when state is changed.
    void
    stateChanged(/*const QString &newState*/);

    //! Emitted when enabled parameter has changed.
    void
    enabledChanged(bool enabled);

    ////! Emitted when an Op parameter has changed.
    //void
    //valueChanged(const QString &valueLongName,
    //             const QString &expr,
    //             int            comp);

    //! Emitted when the EMP body cache has changed.
    void
    empBodyCacheChanged();

    //! Emitted when stepping of the Op begins.
    void
    stepBegin(const NtTimeBundle &tb);

    //! Emitted when stepping of the Op ends.
    void
    stepEnd(const NtTimeBundle &tb);

    //! Emitted when the Op object is destroyed.
    void
    opObjectDestroyed(NsOpObject *op);

private:

    void
    _createPlugs();

    void
    _destroyPlugs();

    void
    _setCondition(Condition c);

private:    // EMP body caching.

    enum _BodyCachePolicy {
        NoCache = 0,
        StatCache,
        FullCache
    };

    //bool
    //_hasEmpCache() const;

    void
    _feedConfig(int &downstreamInputCount, int &dummyInputCount) const;

    void
    _updateEmpBodyCache(const NtTimeBundle &tb);

    static _BodyCachePolicy
    _bodyCachePolicy(int downstreamInputCount, int dummyInputCount);

private:

    template<class P>
    P*
    _findPlug(const QString &plugName) const;

private:    // Member variables.

    typedef QHash<QString,NsPlugObject*>            _PlugHashType;
    typedef QHash<QString,NsInputPlugObject*>       _InputHashType;
    typedef QHash<QString,NsOutputPlugObject*>      _OutputHashType;
    typedef QHash<QString,NsBodyInputPlugObject*>   _BodyInputHashType;
    typedef QHash<QString,NsFieldInputPlugObject*>  _FieldInputHashType;
    typedef QHash<QString,NsBodyOutputPlugObject*>  _BodyOutputHashType;
    typedef QHash<QString,NsFieldOutputPlugObject*> _FieldOutputHashType;

    typedef QList<NsPlugObject*>            _PlugListType;
    typedef QList<NsInputPlugObject*>       _InputListType;
    typedef QList<NsOutputPlugObject*>      _OutputListType;
    typedef QList<NsBodyInputPlugObject*>   _BodyInputListType;
    typedef QList<NsFieldInputPlugObject*>  _FieldInputListType;
    typedef QList<NsBodyOutputPlugObject*>  _BodyOutputListType;
    typedef QList<NsFieldOutputPlugObject*> _FieldOutputListType;


    Ng::Op *_op;  //!< Server resource. TODO: const?
    //mutable Ng::NelContext _nelContext; // HACK!

    Condition _condition;

    NsBodyCache      _empBodyCache;
    _BodyCachePolicy _cachePolicy;

    bool             _hasEmpCacheParam;
    bool             _hasEnabledParam;

    QString          _familyName;
    QString          _typeName;

    _PlugHashType        _plugs;
    _InputHashType       _inputs;
    _OutputHashType      _outputs;
    _BodyInputHashType   _bodyInputs;
    _FieldInputHashType  _fieldInputs;
    _BodyOutputHashType  _bodyOutputs;
    _FieldOutputHashType _fieldOutputs;

    _PlugListType        _orderedPlugs;
    _InputListType       _orderedInputs;
    _OutputListType      _orderedOutputs;
    _BodyInputListType   _orderedBodyInputs;
    _FieldInputListType  _orderedFieldInputs;
    _BodyOutputListType  _orderedBodyOutputs;
    _FieldOutputListType _orderedFieldOutputs;
};

// -----------------------------------------------------------------------------

template<> inline NsPlugObject*
NsOpObject::_findPlug<NsPlugObject>(const QString &plugName) const
{ return _plugs.value(plugName, 0); }
   
template<> inline NsInputPlugObject*
NsOpObject::_findPlug<NsInputPlugObject>(const QString &plugName) const
{ return _inputs.value(plugName, 0); }

template<> inline NsOutputPlugObject*
NsOpObject::_findPlug<NsOutputPlugObject>(const QString &plugName) const
{ return _outputs.value(plugName, 0); }

template<> inline NsBodyInputPlugObject*
NsOpObject::_findPlug<NsBodyInputPlugObject>(const QString &plugName) const
{ return _bodyInputs.value(plugName, 0); }

template<> inline NsFieldInputPlugObject*
NsOpObject::_findPlug<NsFieldInputPlugObject>(const QString &plugName) const
{ return _fieldInputs.value(plugName, 0); }

template<> inline NsBodyOutputPlugObject*
NsOpObject::_findPlug<NsBodyOutputPlugObject>(const QString &plugName) const
{ return _bodyOutputs.value(plugName, 0); }

template<> inline NsFieldOutputPlugObject*
NsOpObject::_findPlug<NsFieldOutputPlugObject>(const QString &plugName) const
{ return _fieldOutputs.value(plugName, 0); }

// -----------------------------------------------------------------------------

inline const NsPlugObject*
NsOpObject::queryConstPlug(const QString &name) const
{ return _findPlug<NsPlugObject>(name); } 

inline const NsInputPlugObject*
NsOpObject::queryConstInput(const QString &name) const
{ return _findPlug<NsInputPlugObject>(name); }

inline const NsOutputPlugObject*
NsOpObject::queryConstOutput(const QString &name) const
{ return _findPlug<NsOutputPlugObject>(name); } 

inline const NsBodyInputPlugObject*
NsOpObject::queryConstBodyInput(const QString &name) const
{ return _findPlug<NsBodyInputPlugObject>(name); }

inline const NsFieldInputPlugObject*
NsOpObject::queryConstFieldInput(const QString &name) const
{ return _findPlug<NsFieldInputPlugObject>(name); }

inline const NsBodyOutputPlugObject*
NsOpObject::queryConstBodyOutput(const QString &name) const
{ return _findPlug<NsBodyOutputPlugObject>(name); }

inline const NsFieldOutputPlugObject*
NsOpObject::queryConstFieldOutput(const QString &name) const
{ return _findPlug<NsFieldOutputPlugObject>(name); }

// -----------------------------------------------------------------------------

inline NsPlugObject*
NsOpObject::queryMutablePlug(const QString &name)
{ return _findPlug<NsPlugObject>(name); } 

inline NsInputPlugObject*
NsOpObject::queryMutableInput(const QString &name)
{ return _findPlug<NsInputPlugObject>(name); }

inline NsOutputPlugObject*
NsOpObject::queryMutableOutput(const QString &name)
{ return _findPlug<NsOutputPlugObject>(name); } 

inline NsBodyInputPlugObject*
NsOpObject::queryMutableBodyInput(const QString &name)
{ return _findPlug<NsBodyInputPlugObject>(name); }

inline NsFieldInputPlugObject*
NsOpObject::queryMutableFieldInput(const QString &name)
{ return _findPlug<NsFieldInputPlugObject>(name); } 

inline NsBodyOutputPlugObject*
NsOpObject::queryMutableBodyOutput(const QString &name)
{ return _findPlug<NsBodyOutputPlugObject>(name); }

inline NsFieldOutputPlugObject*
NsOpObject::queryMutableFieldOutput(const QString &name)
{ return _findPlug<NsFieldOutputPlugObject>(name); }

// -----------------------------------------------------------------------------

#endif // NS_OP_OBJECT_H
